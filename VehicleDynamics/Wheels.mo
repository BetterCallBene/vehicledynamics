within VehicleDynamics;

package Wheels "Wheel, tyre and road models"
    partial model BaseWheel 
        "Properties common to all types of wheels and tyres" 
        import SI = Modelica.SIunits;
        import Car;
        // PARAMETERS COMMON FOR ALL WHEELS
        parameter Real n[3]={0,1,0} 
          "Unit vector in direction of spin axis (same direction for left and right wheel)";
        parameter Boolean leftWheel=true 
          "true, if left wheel, otherwise right wheel";
        parameter Boolean exact=false 
          "false if influence of bearing acceleration is neglected";

        final parameter Real nShape[3]=if leftWheel then n else -n;

        constant SI.Velocity v_eps=1.e-10;


          // Modelica.Constants.eps "1/v_eps should be representable on the machine";

        // GEOMETRIC VARIABLES  
        SI.Angle camberAngle "Angle between wheel plane and contact normal";
        Real cosCamberAngle "Cosine of camber angle";

        SI.Radius Rdym "Distance between wheel center point and contact point";

        SI.Length delta_r 
          "= R0 - Rdym, where R0 is the undeformed wheel radius and Rdym is the distance between wheel center point and contact point";
        Real Sroad[3, 3] 
          "Transformation matrix from road frame to inertial frame";
        Real S[3, 3] 
          "Transformation matrix from wheel carrier frame to road frame";
        Real S2[3, 3] " S2: Transformation matrix from road frame to frame_b";

        SI.Position rRoad0[3] 
          "Position vector from inertial to road frame, resolved in inertial frame";
        SI.Position Cr[3] 
          "Position vector from road frame to C-Frame, resolved in road frame";
        SI.Position Wr[3] 
          "Position vector from road frame to W-Frame, resolved in road frame";
        SI.Position rP0[3] 
          "Position vector from road frame to point P0, resolved in road frame";
        SI.Position rP1[3] 
          "Position vector from road frame to point P1, resolved in road frame";
        SI.Position rC_P1[3] 
          "Position vector from C-frame to point P1, resolved in road frame";
        SI.Position rC_W[3] 
          "Position vector from C-frame to W-frame, resolved in road frame";

        Real nn[3] 
          "Normalized vector of wheel spin axis, resoved in wheel carrier frame";
        Real Ce_x[3] 
          "Unit vector in x-direction of C-Frame, resolved in road frame";
        Real Ce_y[3] 
          "Unit vector in y-direction of C-Frame, resolved in road frame";
        Real Ce_z[3] 
          "Unit vector in z-direction of C-Frame, resolved in road frame";
        Real Ce_z_0[3](start={0,0,1}) "Initial guess for Ce_z";

        Real We_x[3] 
          "Unit vector in x-direction of W-Frame, resolved in road frame";
        Real We_y[3] 
          "Unit vector in y-direction of W-Frame, resolved in road frame";
        Real We_z[3] 
          "Unit vector in z-direction of W-Frame, resolved in road frame";

        SI.AngularVelocity w "Rotational speed of wheel around wheel axis";
        SI.Angle phi "Rotational position of wheel around wheel axis";
        SI.AngularVelocity wWheel[3] 
          "Absolute angular velocity of the rotating wheel, resolved in frame road";
        SI.Velocity Cv[3] 
          "Absolute velocity of wheel center point, resolved in frame road";
        SI.Velocity ddelta_r "Derivative of delta_r (= -der(Rdym))";
        SI.Velocity Wv_x 
          "Absolute velocity of contact point in longitudinal direction We_x";
        SI.Velocity Wv_y 
          "Absolute velocity of contact point in lateral direction We_y";
        SI.Velocity v_x 
          "Absolute velocity of wheel in longitudinal direction We_x";
        SI.Velocity v_y "Absolute velocity of wheel in lateral direction We_y";
      
    protected 
        Real aux1[3] "Auxiliary vector 1 (vector perpendicular to Ce_y and We_z)";
        Real aux2[3] "Auxiliary vector 2";
      
      // THESE FORCES AND TORQUES SHOULD BE GENERATED BY THE TOTAL TYRE MODEL
    public 
        SI.Force F_x "Tyre/contact force at origin of W-frame in x-direction";
        SI.Force F_y "Tyre/contact force at origin of W-frame in y-direction";
        SI.Force F_z "Tyre/contact force at origin of W-frame in z-direction";
        SI.Force M_x "Tyre/contact torque at origin of W-frame in x-direction";
        SI.Force M_y "Tyre/contact torque at origin of W-frame in y-direction";
        SI.Force M_z "Tyre/contact torque at origin of W-frame in z-direction";
        // ********************************************************************

        // RESULTANT FORCES ANS TORQUES
        SI.Force Wf[3] 
          "Tyre/contact force at origin of W-frame, resolved in road frame";
        SI.Torque Wt[3] "Tyre/contact torque at W-frame, resolved in road frame";
        SI.Torque Ct[3] 
          "Tyre torque acting at wheel center, resolved in wheel_body frame";
        SI.Torque Ct_tyre 
          "Tyre torque acting at wheel center in direction of spin axis";


          // *********************************************************************  

        Road road;
        Road road2;
        Real mueRoad;
        Real altitudeRoad;
        Real normalRoad[3];
      
    public 
        outer block Road = Environments.Interfaces.TyreRoadInterface;
      
    public 
        replaceable Wheels.Utilities.WheelData wheelData
        annotation (extent=[0, 37; 20, 57]);
        annotation (
        Documentation(info="This element is a superclass of wheel/tyre
        systems. It contains all the equations which are independent of the
        tyre model. Especially, the contact point of wheel and road, as well
        as the contact velocities are computed.
        The frames of this object have the following meaning:
        Frame carrierFrame is fixed in the carrier of the wheel
        and is located on the spin axis of the wheel in the
        middle point of the wheel. This point is also approximately
        used as the center-of-mass of the wheel.
        It is temporarily assumed that the road lies in the
        x-y plane of the inertial frame! This restriction can
        be removed by defining the road properties via inner/outer
        functions.
        Flange XXX is used to drive the wheel with a 1D-drive train.
        This element is realized according to the description:
        Georg Rill: Simulation von Kraftfahrzeugen, Vieweg, 1994
        "), 
        Coordsys(
          extent=[-100, -100; 100, 100], 
          grid=[1, 1], 
          component=[20, 20]), 
        Window(
          x=0.04, 
          y=0.05, 
          width=0.52, 
          height=0.89), 
        Icon(
          Text(extent=[-113, -102; 111, -139], string="%name"), 
          Polygon(points=[-60, -40; -50, -40; -50, 90; 40, 90; 40, 100; -60, 
                100; -60, -40], style(color=0, fillColor=8)), 
          Rectangle(extent=[-100, -79; 100, -100], style(
              color=0, 
              fillColor=7, 
              fillPattern=8)), 
          Rectangle(extent=[40, 10; 60, -10], style(
              color=0, 
              gradient=2, 
              fillColor=8)), 
          Rectangle(extent=[-35, 76; 40, -80], style(gradient=2, fillColor=10))), 
           
        Diagram(
          Text(
            extent=[-5, 98; 25, 92], 
            string="Tyre-Force", 
            style(color=10)), 
          Text(extent=[-55, 23; -55, 18], string=
                "(forward moving direction in wheel plane)"), 
          Text(extent=[-68, 31; -68, 26], string="(perpendicular to road)"), 
          Line(points=[29, 41; 30.51, 55.2; 31.71, 65.2; 32.92, 73.7; 34.13, 
                80.8; 35.63, 87.8; 37.14, 93; 38.65, 96.6; 40.5, 99.3; 42.6, 
                100.8; 46.2, 100.8; 51.9, 98.6; 63.7, 92.2; 68.5, 91; 89, 91], 
              style(color=0, thickness=2)), 
          Line(points=[-100, -1; -100, 31], style(arrow=1)), 
          Line(points=[-100, 0; -124, 0], style(arrow=1)), 
          Line(points=[-100, 0; -80, 16], style(arrow=1)), 
          Text(
            extent=[-99, 41; -41, 31], 
            string="usual selection of reference system", 
            style(color=41)), 
          Text(extent=[-162, -12; -88, -18], string=
                "(spin axis, towards left vehicle side)"), 
          Text(extent=[-79, 21; -76, 13], string="x"), 
          Text(extent=[-123, 0; -126, -9], string="y"), 
          Text(extent=[-97, 32; -94, 24], string="z"), 
          Line(points=[29, 41; 89, 41], style(color=10, arrow=1)), 
          Line(points=[29, 41; 29, 100], style(color=10, arrow=1)), 
          Text(
            extent=[77, 51; 91, 44], 
            string="slip", 
            style(color=10)), 
          Line(points=[45, 101; 45, 41], style(color=10, pattern=2)), 
          Line(points=[69, 91; 69, 41], style(color=10, pattern=2)), 
          Text(
            extent=[59, 39; 77, 34], 
            string="s_Fslide", 
            style(color=10)), 
          Text(
            extent=[35, 39; 54, 34], 
            string="s_Fmax", 
            style(color=10)), 
          Rectangle(extent=[-4, 105; 100, 33], style(color=10))));
      
        ModelicaAdditions.MultiBody.Forces.ExtForce tyreForceWheelCenter
          annotation (extent=[-37, -56; -57, -36], rotation=180);
        ModelicaAdditions.MultiBody.Forces.ExtTorque tyreTorqueWheelCenter
          annotation (extent=[-37, -56; -57, -76], rotation=180);
        ModelicaAdditions.MultiBody.Interfaces.Frame_a carrierFrame
          annotation (extent=[-80, -10; -60, 10]);
        Modelica.Mechanics.Rotational.Interfaces.Flange_a driveShaft1D
          annotation (extent=[80, 10; 60, -10], rotation=180);
        Modelica.Mechanics.Rotational.Torque drivingTyreTorque
          annotation (extent=[-34, -5; -14, 15]);
        ModelicaAdditions.MultiBody.Joints.Revolute hub(n={0,1,0})
          annotation (extent=[-21, -28; -1, -8]);
        ModelicaAdditions.MultiBody.Parts.Body2 wheel_body(
            m=wheelData.m, 
            I11=wheelData.Ixx, 
            I22=wheelData.Iyy, 
            I33=wheelData.Ixx) annotation (extent=[11, -27; 31, -7]);
    equation 
        road.x = Wr[1];
        road.y = Wr[2];
        //road.v = 0;
        //temporarilly
        road.mue = mueRoad;
        road.z = altitudeRoad;
        road.n = normalRoad;

        connect(wheel_body.frame_a, hub.frame_b)
          annotation (points=[10.5, -17; 5, -29; 5, -18; -0.5, -18]);
        connect(hub.frame_a, carrierFrame)
          annotation (points=[-21.5, -18; -42, -30; -42, 0; -70, 0]);
        connect(drivingTyreTorque.flange_b, hub.axis)
          annotation (points=[-14, 5; -11, 5; -11, -11], style(color=0));
        connect(driveShaft1D, hub.axis)
          annotation (points=[70, 0; -11, 0; -11, -11], style(color=0));

        /* Definition of road:
        1. A road frame is defined which is fixed in the inertial frame and
           which is defined relatively to the inertial frame. This frame is
           defined as:
             Sroad : Transformation matrix from road frame to inertial frame.
             rroad0: Position vector from inertial frame origin to the
                     origin of the road frame, resolved in the inertial frame.
        2. The z-axis of the road frame points upwards. The road surface
           is defined as (Wr_z, We_z) = f(Wr_x, Wr_y), where
              Wr_x, rWy, rWz are the x-, y-, z-coordinates of the wheel/road
              contact point with respect to the road frame and
              We_z is the unit vector at the contact point which is
              perpendicular to the surface and points upwards.
        Temporarily it is assumed that the road is a plane at z=0 of the inertial
        frame. Still, the equations below are written for a general road profile.
        This assumption should be replaced later.
        The friction coefficient mue of the road is temporarily set to the
        nominal friction coefficient data.mue_max of the tyre.
        The determination of the contact point of wheel and road requires
        the solution of a nonlinear system of equations. However, since the
        contact area of the tyre of a car is a rectangle with about 10 cm x 20 cm
        area and the road is approximated in the order of centimeters, it does not
        make much sense to determine the "virtual" contact point very exactly.
        Below one iteration of a fixed point iteration scheme is used to solve
        this nonlinear system of equations. This works well, provided a good
        initial guess Ce_z_0 for the unit vector Ce_z (normalized vector from
        wheel center point to contact point), is available. A good guess is
        - a unit vector which is fixed in the main car body and points
          into the z-direction of the road frame when the car is at rest.
        - a unit vector which is fixed in the wheel carrier and points
          into the z-direction of the road frame when the car is at rest.
        - the value of Ce_z at the previous integration step.
        Temporarily, this initial guess is set for the case that
        the road is a plane at z=0.
        Note, that the exact nonlinear system of equations is constructed
        by replacing the equation for Ce_z_0 below by the equation:
            Ce_z = Ce_z_0;
        and by using an appropriate initial guess for Ce_z_0.
    */
        Sroad = identity(3);
        rRoad0 = zeros(3);
        //Ce_z_0 = Ce_z;
        Ce_z_0 = {0,0,1};
        //mueRoad = 0.7;
        //(mueRoad,altitude) = Road(Wr[1], Wr[2], sqrt(Wv_x*Wv_x + Wv_y*Wv_y));
        /* Definition of the ISO coordinate systems of the wheel:
        Frame C (ISO-C, TYDEX C axis system) is fixed to the wheel carrier.
          - The origin is described by vector Cr, from the origin of the
            road frame to the wheel center, resolved in the road frame.
          - The x-axis (= unit vector Ce_x) is parallel to the road tangent plane
            within the wheel plane
          - The y-axis (= unit vector Ce_y) is normal to the wheel plane and
            therefore parallel to the wheels spin axis.
          - The z-axis (= unit vector Ce_z) is orthogonal to the x- and y-axis, i.e.,
            it is a unit vector along the line from the contact point to
            the wheel center point.
        Frame W (ISO-W, TYDEX W axis system) is fixed at the contact point
        of the wheel and the road.
          - The origin is described by vector Wr, from the origin of the
            road frame to the tyre contact point, resolved in the road frame.
          - The x-axis (= unit vector We_x) lies in the local road tangent plane
            along the intersection of the wheel plane and the local road plane,
            i.e., it is parallel to the x-axis of frame C.
          - The z-axis (= unit vector We_z) is perpendicular to the local
            road tangent plane and points upward.
          - The y-axis (= unit vector We_y) lies in the local road plane and
            is perpendicular to the x- and z-axis.
        All vectors describing frame C and frame W are resolved in the
        road frame. Note, that We_x = Ce_x (but We_y <> Ce_y)
    */
      
        /* Determine C-frame, where all vectors are resolved in the road frame.
         n: spin-axis in wheel carrier frame;
         S: transformation matrix from wheel carrier frame to road frame).
    */
        S = transpose(Sroad)*carrierFrame.S;
        nn = n/sqrt(n*n);
        Ce_x = We_x;
        Ce_y = S*n;
        Ce_z = cross(Ce_x, Ce_y);
        Cr = transpose(Sroad)*(carrierFrame.r0 - rRoad0);
        
        /* Determine W-frame, where all vectors are resolved in the road frame.
         As shortly discussed above, this is performed by one iteration of a
         fixed point iteration scheme, constructing three points P0, P1, P2:
         Point P0: Defined by position vector Wr_0 which is computed using
                   the initial guess We_z_0 for We_z.
         Point P1: P0 is usually not on the road. The x-,y-coordinates of P0
                   are used for P1. The z-coordinate is computed by using
                   the road surface function. In point P1 the contact frame W
                   is constructed. This defines especially the contact plane.
         Point P2: P1 is moved in the constructed contact plane, such that
                   it is the intersection of the contact plane with the line
                   along Ce_z, i.e., along the line from the wheel-center point
                   to the contact point (which is computed above as cross
                   product of the wheel spin axis Ce_y and of We_x computed
                   for point P1).
         rP0     : Position vector from road frame origin to point P0.
         rP1     : Position vector from road frame origin to point P1.
                   Temporarily, rP1[3] is set to 0 and We_z is set to {0,0,1}.
                   Later the road surface function should be used to calculate
                   these values.
         Rdym    : Distance between wheel center point and contact point.
         rC_W    : Position vector from C-frame origin to W-frame origin.
                   During the contact point calculation (iteration), this is
                   the vector from C-frame origin to point P2.
                     rC_W = -Rdym*Ce_z
                          = rC_P1 + a*We_x + b*We_y;
                        multiply rC_W with We_z
                     We_z*rC_W = -Rdym*We_z*Ce_z
                               = We_z*rC_P1  (We_z is perpendicular to We_x and We_y)
                        solve for Rdym
                     Rdym = -(We_z*rC_P1)/(We_z*Ce_z)
    */
        rP0 = Cr - wheelData.R0*Ce_z_0;

        //road has to be called twice
        road2.x = rP0[1];
        road2.y = rP0[2];
        //road2.v = 0;
        rP1 = {rP0[1],rP0[2],road2.z};
        // general road: rP1[3] = f(rP1[1], rP1[2]);
        We_z = road2.n;
        //{0,0,1};
        // general road: We_z = f(rP1[1], rP1[2]);
        aux1 = cross(Ce_y, We_z);
        We_x = aux1/noEvent(sqrt(aux1*aux1));
        We_y = cross(We_z, We_x);

        rC_P1 = rP1 - Cr;
        cosCamberAngle = We_z*Ce_z;
        Rdym = -(We_z*rC_P1)/cosCamberAngle;
        rC_W = -Rdym*Ce_z;
        Wr = Cr + rC_W;

        /* Compute characteristic values of the contact:
         delta_r    : Distance between undeformed wheel point and contact point
                      R0 = Rdym + delta_r
         delta_z    : Radial tyre deflection
                      (= wheel deformation in z-direction of C-frame)
                      delta_z = delta_r if the wheel is in contact with the road
         camberAngle: Angle between wheel plane and We_z
                      (cos(pi/2 - camberAngle) = Ce_y*We_z)
        */
        delta_r = wheelData.R0 - Rdym;
        camberAngle = Modelica.Math.asin(Ce_y*We_z);

        /* Determine contact point velocities
         wWheel  : Absolute angular velocity of the rotating wheel, resolved in frame road
         ddelta_r: derivative of delta_r (= -der(Rdym))
         Cv      : Absolute velocity of wheel center point, resolved in frame road
         Wv      : Absolute velocity of contact point, resolved in frame road
                     Wv = der(Wr)
                        = der(Cr) + cross(wWheel, rC_W) + der(abs(rCW))*(-Ce_z)
                        = Cv + cross(wWheel, rC_W) + der(R0 - delta_r)*(-Ce_z)
                        = Cv + cross(wWheel, rC_W) + der(delta_r)*Ce_z
                     Wv has to be in the road plane. Therefore We_z*Wv = 0
                       0 = We_z*Wv = We_z*(Cv + cross(wWheel, rC_W)) + We_z*Ce_z*ddelta_r
                       ddelta_r = -We_z*(Cv + cross(wWheel, rC_W)) / (We_z*Ce_z)
         Wv_x  : Absolute velocity of contact point in longitudinal direction
                 = We_x*Wv
                 = We_x*(Cv + cross(wWheel, rC_W) + ddelta_r*Ce_z)
                 = We_x*(Cv + cross(wWheel, rC_W))
                 since We_x*Ce_z = Ce_x*Ce_z = 0
         Wv_y  : Absolute velocity of contact point in lateral direction
                 = We_y*Wv
                 = We_y*(Cv + cross(wWheel, rC_W) + ddelta_r*Ce_z)
         Wv_z  : Absolute velocity of contact point in normal direction
                 = 0
        */
        wWheel = S*(carrierFrame.w + n*w);
        Cv = S*carrierFrame.v;
        aux2 = Cv + cross(wWheel, rC_W);
        ddelta_r = -We_z*aux2/cosCamberAngle;
        Wv_x = We_x*aux2;
        Wv_y = We_y*(aux2 + ddelta_r*We_z);
        
        //DETERMINE THE WHEEL CONTACT POINT VELOCITY
        v_x = Cv*We_x;
        v_y = Cv*We_y;
        
        //STATES OF WHEEL ROTATION
        w = hub.qd;
        phi = hub.q;
        
        //EXPRESSIONS FOR F_x, F_y, F_z, M_x, M_y, M_z AT EACH WHEEL MODEL
        Wf = We_x*F_x + We_y*F_y + We_z*F_z;
        Wt = We_x*M_x + We_y*M_y + We_z*M_z;
        
        // tyre forces shall act at wheel center point
        // S2: Transformation matrix from road frame to frame_b
        S2 = transpose(hub.frame_a.S)*Sroad;
        Ct = S2*(cross(rC_W, Wf) + Wt);
        Ct_tyre = nn*Ct;
        tyreForceWheelCenter.inPort.signal = S2*Wf;
        tyreTorqueWheelCenter.inPort.signal = Ct - nn*Ct_tyre;
        drivingTyreTorque.inPort.signal = {Ct_tyre};
        
        connect(tyreForceWheelCenter.frame_b, carrierFrame)
          annotation (points=[-36.5, -46; -70, 0]);
        connect(tyreTorqueWheelCenter.frame_b, carrierFrame)
          annotation (points=[-36.5, -66; -27, -38; -70, 0]);
    end BaseWheel;
    
    
end Wheels;